# Java垃圾回收机制 #

	参考：http://www.cnblogs.com/laoyangHJ/articles/java_gc.html

- 垃圾回收机制的目的在于清理不再使用的对象；
- 通过确定对象是否被活动对象引用来确定是否收集；
- 通过引用计数和对象引用遍历来进行收集。

使用垃圾收集器必要的知识：

- 每个对象只能调用finalize( )方法一次。如果在finalize( )方法执行时产生异常（exception），则该对象仍可以被垃圾收集器收集。

- 垃圾收集器跟踪每一个对象，收集那些不可触及的对象（即该对象不再被程序引用了），回收其占有的内存空间。但在进行垃圾收集的时候，垃圾收集器会调用该对象的finalize( )方法（如果有）。如果在finalize()方法中，又使得该对象被程序引用(俗称复活了)，则该对象就变成了可触及的对象，暂时不会被垃圾收集了。但是由于每个对象只能调用一次finalize( )方法，所以每个对象也只可能 "复活 "一次。

- Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为该方法调用后的执行结果是不可预知的。

- 垃圾收集器不可以被强制执行，但程序员可以通过调研System.gc方法来建议执行垃圾收集。记住，只是建议。一般不建议自己写System.gc，因为会加大垃圾收集工作量。

---
### 引用计数法 ###
垃圾回收机制早期策略。堆内部的<font color="red">**每个对象**</font>都有引用计数。任何引用计数为0的对象可以被当作垃圾收集。

- 引用计数+1的情况：
	- 对象创建；
	- 给对象被引用给其他变量；
- 引用计数 -1的情况：
	- 引用该对象的变量超出生命周期；
	- 引用该对象的变量赋值其他对象的引用；


优点：

		引用计数收集器可以很快的执行，交织在程序运行中。对程序不
	被长时间打断的实时环境比较有利。

缺点：

		循环引用无法检测回收。
---
### 跟踪收集法 ###
垃圾回收机制早期策略。使用对象引用进行遍历。GC可使用单、多线程增加效率。

过程：
- 从一组对象开始，沿对象的每个属性链接，递归确定可到达的对象；
- 如果某对象不能被任何递归到达，GC将会记住可以到达的对象；
- GC要删除不可到达的对象后，释放内存生成新的对象，多个小段对象组合，组织内存中的对象，进行压缩，形成可利用的空间；
- GC停止其他的活动，所有与应用程序相关的工作停止。
	

常用的垃圾收集器

- 标记清除收集器

		单进程工作并停止其他工作。
		清除未被标记的对象而不压缩导致大量内存碎片，造成浪费。

- 标记压缩收集器

		将标记对象复制到堆栈新域以便压缩堆栈，同时停止其他操作。

- 复制收集器

		- 堆栈分为两个域，每次只使用一半空间。
		- gc运行时复制到另一个域，压缩堆栈。
		- 持续复制长生存期的对象将导致效率降低，要求内存大。

- <font color="red">增量收集器</font>

		- 将堆栈分为多个块儿，每次gc对其中一个块儿进行垃圾收集。
		- 用户一般不会察觉到gc的工作。

- <font color="red">分代收集器</font>

		- 长生命周期对象拷贝造成事件内存浪费；
		- 堆栈分为多个块儿，存放不同寿命的对象；
		- 一段时间间隔，将继续存在的对象转入生命周期长的域内；
		- 不同域有不同算法。


---
### <font color="Blue">JVM GC工作原理</font>

#### JVM结构 ####
JVM内存结构由堆、栈、本地方法栈、方法区等部分组成。

1. 方法区

2. 本地方法栈

3. 栈

4. 堆


#### 原理 ####
















---

	参考:
	http://blog.csdn.net/u012152619/article/details/46968883
	http://www.jianshu.com/p/c9ac99b87d56
	http://www.cnblogs.com/laoyangHJ/articles/java_gc.html
	https://juejin.im/entry/581198675bbb50005b84f2bb
	http://www.jianshu.com/p/c9ac99b87d56
	http://www.jianshu.com/p/380fa5c92dcc	