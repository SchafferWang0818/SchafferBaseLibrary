# Java垃圾回收机制 #

	参考：http://www.cnblogs.com/laoyangHJ/articles/java_gc.html

- 垃圾回收机制的目的在于清理不再使用的对象；
- 通过确定对象是否被活动对象引用来确定是否收集；
- 通过引用计数和对象引用遍历来进行收集。

---
### 引用计数法 ###
垃圾回收机制早期策略。堆内部的<font color="red">**每个对象**</font>都有引用计数。任何引用计数为0的对象可以被当作垃圾收集。

- 引用计数+1的情况：
	- 对象创建；
	- 给对象被引用给其他变量；
- 引用计数 -1的情况：
	- 引用该对象的变量超出生命周期；
	- 引用该对象的变量赋值其他对象的引用；


优点：

		引用计数收集器可以很快的执行，交织在程序运行中。对程序不
	被长时间打断的实时环境比较有利。

缺点：

		循环引用无法检测回收。
---
### 跟踪收集法 ###
垃圾回收机制早期策略。使用对象引用进行遍历。GC可使用单、多线程增加效率。

过程：
- 从一组对象开始，沿对象的每个属性链接，递归确定可到达的对象；
- 如果某对象不能被任何递归到达，GC将会记住可以到达的对象；
- GC要删除不可到达的对象后，释放内存生成新的对象，多个小段对象组合，组织内存中的对象，进行压缩，形成可利用的空间；
- GC停止其他的活动，所有与应用程序相关的工作停止。
	

常用的垃圾收集器

- 标记清除收集器

		单进程工作并停止其他工作。
		清除未被标记的对象而不压缩导致大量内存碎片，造成浪费。

- 标记压缩收集器

		将标记对象复制到堆栈新域以便压缩堆栈，同时停止其他操作。

- 复制收集器

		- 堆栈分为两个域，每次只使用一半空间。
		- gc运行时复制到另一个域，压缩堆栈。
		- 持续复制长生存期的对象将导致效率降低，要求内存大。

- <font color="red">增量收集器</font>

		- 将堆栈分为多个块儿，每次gc对其中一个块儿进行垃圾收集。
		- 用户一般不会察觉到gc的工作。

- <font color="red">分代收集器</font>

		- 长生命周期对象拷贝造成事件内存浪费；
		- 堆栈分为多个块儿，存放不同寿命的对象；
		- 一段时间间隔，将继续存在的对象转入生命周期长的域内；
		- 不同域有不同算法。


---


